/* Generated By:JavaCC: Do not edit this line. LexicoSintactico.java */
import java.util.*;
import java.io.*;

class LexicoSintactico implements LexicoSintacticoConstants {
         public static String parser = "Descendente ";

        //###############   PARA FUNCIONES   ######################################################
        static FormatoTS elemento = new FormatoTS("","","",0,null);
        static String idFuncion;
        static String tipoFuncion = "";
        static int contParam = 0;
        static ArrayList<String> tipoParams = new ArrayList<String>();
        static String idParam = "";
        static boolean esLocal = false;

        //###############   PARA FUERA DE FUNCIONES   #############################################
        static String variable;
        static String tipoVariable;

        //############### RESTO DE AUXILIARES #####################################################
        static String tipoRetorno = "";
        static String tipoIzq = "";
        static boolean esRetorno = false;
        static String derLlamada="";
        static String der="";
        static String izq=""; //a=b()
        static boolean esLlamada=false;
        static String copiaLLamada=""; //cogemos el lexema de la llamada
        static int contParamLlamada=0;
        static String tipoArrayParam="";
        static ArrayList<String> tipoParamsLlamada = new ArrayList<String>();


        static boolean esExp=false;
        static int contExp=0;

        static boolean esMayor=false;
        static boolean esSuma=false;
        static boolean esAnd=false;
        static boolean esDecremento=false;
		static boolean esParantC=false;
        static String primerMayor="";
        static String primerSuma="";
        static String primerAnd="";
        static String tipoDec="";

        public static void main( String[] args) throws ParseException,IOException
        {
                LexicoSintactico analizador = new LexicoSintactico(System.in);
                analizador.Iniciar();
                System.out.println("Fin de ejecuciOn");
                generarToken.imprimir();
                generarParser.imprimir();
        }

  static final public void Iniciar() throws ParseException {
        TablaDeSimbolos.crearTablaGlobal();
        TablaDeSimbolos.imprimirPalR();
		parser += "1 ";
    P();
  }

  static final public void P() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VAR:
    case PROMPT:
    case WRITE:
    case WHILE:
    case IF:
    case RETURN:
    case ID:
		parser += "2 ";
      B();
            tipoRetorno="";
      P();
      break;
    case FUNCTION:
		parser += "3 ";
      F();
      P();
      break;
    case 0:
		parser += "4 ";
      jj_consume_token(0);
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void F() throws ParseException {
	  parser += "5 ";
    jj_consume_token(FUNCTION);
    HH();
    jj_consume_token(ID);
                idFuncion=token.image;
                generarToken.insertar("Identificador",token.image);
    jj_consume_token(PAREN_A);
                  generarToken.insertar("ParentesisAbierto","(");
    A();
    jj_consume_token(PAREN_C);
                if(TablaDeSimbolos.busquedaFuncion("function",idFuncion,tipoFuncion,contParam,tipoParams)==true){
                        System.out.println("Ya existe la funcion--> "+idFuncion+" Linea: "+token.beginLine);
                }else{
                        // System.out.println("Insertamos funcion : '"+idFuncion+"' con numero de parametros: "+contParam);
                        elemento = new FormatoTS("function",idFuncion,tipoFuncion,contParam,tipoParams);
                        tipoParams=new ArrayList<String>();//Reinicializamos
                        tipoFuncion="";
                        TablaDeSimbolos.insertarTsgFun(elemento);
                }

                generarToken.insertar("ParentesisCerrado",")");
    jj_consume_token(LLAVE_A);
                //Limpiamos tipoIzq
                tipoIzq="";
                //Para tsl 
                TablaDeSimbolos.imprimirTitulo();
                TablaDeSimbolos.imprimirParam();
                generarToken.insertar("LlaveAbierta","{");
                esLocal=true;
    C();
    jj_consume_token(LLAVE_C);
                TablaDeSimbolos.setTablesLocal();
                esLocal=false;
                contParam=0;//Reiniciamos contadores
                generarToken.insertar("LlaveCerrada","}");
  }

  static final public void HH() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT:
    case CHARS:
    case BOOL:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INT:
	  parser += "6 ";
        jj_consume_token(INT);
                tipoFuncion=token.image;
                tipoRetorno=token.image;
        break;
      case CHARS:
	  parser += "7 ";
        jj_consume_token(CHARS);
                tipoFuncion=token.image;
                tipoRetorno=token.image;
        break;
      case BOOL:
	  parser += "8 ";
        jj_consume_token(BOOL);
                tipoFuncion=token.image;
                tipoRetorno=token.image;
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
	parser += "9 ";
      jj_la1[2] = jj_gen;
      ;
    }
  }

  static final public void A() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT:
    case CHARS:
    case BOOL:
	parser += "10 ";
      H();
      jj_consume_token(ID);
                contParam++;
                //Para tsl
                idParam=token.image;//ADEMAS AQUI CREO Q SOLO BASTA CON INTRODUCIR PORQUE ES EL PRIMER PARAM
                if(TablaDeSimbolos.busquedaParamTsl(idParam)==true){
                        System.out.println("Ya existe el parametro-->"+idParam+" Linea: "+token.beginLine);
                }else{

                        elemento = new FormatoTS("var",idParam,tipoVariable,0,null);//MIRAAAAaaaaaaaaaaaaaaaaaR
                        TablaDeSimbolos.insertarTslParam(elemento);
                }
                generarToken.insertar("Identificador",token.image);
      R();
      break;
    default:
	parser += "11 ";
      jj_la1[3] = jj_gen;
      ;
    }
  }

  static final public void R() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMA:
	parser += "12 ";
      jj_consume_token(COMA);
      H();
      jj_consume_token(ID);
                contParam++;
                //Para tsl 
                idParam=token.image;
                if(TablaDeSimbolos.busquedaParamTsl(idParam)==true){
                        System.out.println("Ya existe el parametro--> "+idParam+" Linea: "+token.beginLine);
                }else{

                        elemento = new FormatoTS("var",idParam,tipoVariable,0,null);
                        TablaDeSimbolos.insertarTslParam(elemento);
                }

                generarToken.insertar("Identificador",token.image);
      R();
      break;
    default:
	parser += "13 ";
      jj_la1[4] = jj_gen;
      ;
    }
  }

  static final public void C() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VAR:
    case PROMPT:
    case WRITE:
    case WHILE:
    case IF:
    case RETURN:
    case ID:
	parser += "14 ";
      B();
      C();
      break;
    default:
	parser += "15 ";
      jj_la1[5] = jj_gen;
      ;
    }
  }

  static final public void B() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VAR:
	parser += "16 ";
      jj_consume_token(VAR);
      H();
      jj_consume_token(ID);
                variable=token.image;
                if(esLocal==false){
                        if(TablaDeSimbolos.busquedaVar("var",variable)==true){
                                System.out.println("Ya existe la variable--> "+variable+" Linea: "+token.beginLine);
                        }else{
                                // System.out.println("Insertamos variable : '"+variable+"' de tipo: '"+tipoVariable+"'");
                                elemento = new FormatoTS("var",variable,tipoVariable,0,null);
                                // tipoVariable="";//Reinicializamos
                                TablaDeSimbolos.insertarTsgVar(elemento);
                        }
                }else{//Local
                        if(TablaDeSimbolos.busquedaVarTsl(variable)==true){
                                System.out.println("Ya existe la variable local--> "+variable+" Linea: "+token.beginLine);
                        }else{

                                elemento = new FormatoTS("var",variable,tipoVariable,0,null);
                                TablaDeSimbolos.insertarTslVar(elemento);
                        }
                }
                tipoParams=new ArrayList<String>();//Reinicializamos para que no de conflicto en function
                generarToken.insertar("Identificador",token.image);
      W();
             tipoIzq = "";
      break;
    case IF:
	parser += "17 ";
      jj_consume_token(IF);
      jj_consume_token(PAREN_A);
                        generarToken.insertar("ParentesisAbierto","(");
      E();
                esMayor=false; esSuma=false; esAnd=false;esDecremento=false;
      jj_consume_token(PAREN_C);
                generarToken.insertar("ParentesisCerrado",")");
      S();
      break;
    case WHILE:
	parser += "18 ";
      jj_consume_token(WHILE);
      jj_consume_token(PAREN_A);
                           generarToken.insertar("ParentesisAbierto","(");
      E();
      jj_consume_token(PAREN_C);
                                                                                        generarToken.insertar("ParentesisCerrado",")");
      jj_consume_token(LLAVE_A);
                  generarToken.insertar("LlaveAbierta","{");
      C();
      jj_consume_token(LLAVE_C);
                  generarToken.insertar("LlaveCerrada","}");
      break;
    case PROMPT:
    case WRITE:
    case RETURN:
    case ID:
	parser += "19 ";
      S();
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void S() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PROMPT:
	parser += "20 ";
      jj_consume_token(PROMPT);
      jj_consume_token(PAREN_A);
                          generarToken.insertar("ParentesisAbierto","(");
      jj_consume_token(ID);
                if(esLocal==false){
                        String varPrompt = TablaDeSimbolos.buscarIDTsg(token.image);

                        if(varPrompt != null){
                                if(!varPrompt.equals("int") && !varPrompt.equals("chars")){
                                        System.out.println("Error semantico: la variable en prompt es de tipo bool en la linea "+token.beginLine);
                                }
                        }else{

                                FormatoTS sinDeclarar = new FormatoTS("var",token.image,"int",0,null);
                                TablaDeSimbolos.insertarTsgVar(sinDeclarar);
                        }
                }else{//LOCAL
                        String varPrompt = TablaDeSimbolos.buscarIDTsl(token.image);
                        if(varPrompt==null){
                                varPrompt = TablaDeSimbolos.buscarIDTsg(token.image);
                                if(varPrompt==null){
                                        FormatoTS sinDeclarar = new FormatoTS("var",token.image,"int",0,null);
                                        TablaDeSimbolos.insertarTsgVar(sinDeclarar);
                                }else{
                                        if(!varPrompt.equals("int") && !varPrompt.equals("chars")){
                                        System.out.println("Error semantico: la variable en prompt es de tipo bool en la linea "+token.beginLine);
                                        }
                                }
                        }else{
                                if(!varPrompt.equals("int") && !varPrompt.equals("chars")){
                                        System.out.println("Error semantico: la variable en prompt es de tipo bool en la linea "+token.beginLine);
                                }
                        }
                }

                generarToken.insertar("Identificador",token.image);
      jj_consume_token(PAREN_C);
                   generarToken.insertar("ParentesisCerrado",")");
      break;
    case WRITE:
	parser += "21 ";
      jj_consume_token(WRITE);
      jj_consume_token(PAREN_A);
                           generarToken.insertar("ParentesisAbierto","(");
      E();
      jj_consume_token(PAREN_C);
                                                                                        generarToken.insertar("ParentesisCerrado",")");
      break;
    case RETURN:
	parser += "22 ";
      jj_consume_token(RETURN);
                esRetorno = true;
                generarToken.insertar("PalabraReservada","return");
      X();
             esRetorno=false; contExp=0; esMayor=false; esSuma=false; esAnd=false;
      break;
    case ID:
	parser += "23 ";
      jj_consume_token(ID);
                der = token.image;
                izq=token.image; // para asignacion

                generarToken.insertar("Identificador",token.image);
      Sp();
                // if(esLocal==false)
                // {
                        // String derecha = TablaDeSimbolos.buscarIDTsg(der); //devuelve int, chars, bool

                        // if(derecha!=null)
                        // {
                                // if(!derecha.equals(tipoIzq) && tipoIzq!="" && esRetorno==false)
                                // {
                                        // System.out.println("Error semSantico: la variable "+der+" no es de tipo (int) en la lÃ­nea "+token.beginLine);
                                // }

                        // }else //no existe variable
                        // {
                                // FormatoTS sinDeclarar = new FormatoTS("var",der,"int",0,null);
                                // TablaDeSimbolos.insertarTsgVar(sinDeclarar);
                        // }	
                // }else{
                        // String derecha = TablaDeSimbolos.buscarIDTsl(der);
                        // if(){

                        // }

                        if(esDecremento==true){
                                if(tipoDec!="int")
                                        System.out.println("Error semantico: la comprobacion de postDecremento no es correcta Linea: "+token.beginLine);
                                        esDecremento=false;
                        }

                // }

      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void Sp() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PAREN_A:
	parser += "24 ";
      jj_consume_token(PAREN_A);
                  contExp=0;esLlamada=true; generarToken.insertar("ParentesisAbierto","(");
      L();
      jj_consume_token(PAREN_C);
                // if(esLocal==false)
                // {	
                        // System.out.println("IZQ: "+izq);
                        // System.out.println("parametros : "+contParamLlamada);
                        // System.out.println("IZQ: "+izq);
                        String derLlamada2 = TablaDeSimbolos.buscarLlamadaTsg(izq,contParamLlamada, tipoParamsLlamada);
                        if(derLlamada2 != null)
                        {
                                if(!tipoIzq.equals(derLlamada2) && tipoIzq != "" && esRetorno==false)
                                {
                                        System.out.println("Error semantico: tipo izqG("+tipoIzq+") no coincide tipo der ("+derLlamada2+") --> "+izq+" en la l\u00c3\u00adnea "+token.beginLine);
                                }
                        }else
                        {
                                System.out.println("Error Sem\u00c3\u00a1tico: la funci\u00c3\u00b3n "+izq+" no est\u00c3\u00a1 declarada con n\u00c2\u00ba de parametros: "+contParamLlamada+" o con tipo de parametros distintos en la l\u00c3\u00adnea "+token.beginLine);

                        }
                // }else{
					
				// }
                esLlamada=false;
                contParamLlamada=0;
                contExp=0;
                tipoParamsLlamada = new ArrayList<String>();

                generarToken.insertar("ParentesisCerrado",")");
      break;
    case ASIG:
	parser += "25 ";
      jj_consume_token(ASIG);
                if(esLocal==false)
                {

                        String derecha = TablaDeSimbolos.buscarIDTsg(izq); //devuelve int, chars, bool

                        if(derecha!=null)
                        {
                                tipoIzq=derecha;
                        }else //no existe variable
                        {
                                FormatoTS sinDeclarar = new FormatoTS("var",izq,"int",0,null);
                                TablaDeSimbolos.insertarTsgVar(sinDeclarar);
                                tipoIzq="int";
                        }
                }else{
                        String derecha = TablaDeSimbolos.buscarIDTsl(izq); //devuelve int, chars, bool

                        if(derecha==null)
                        {
                                derecha = TablaDeSimbolos.buscarIDTsg(izq);
                                if(derecha==null){
                                        FormatoTS sinDeclarar = new FormatoTS("var",izq,"int",0,null);
                                        TablaDeSimbolos.insertarTsgVar(sinDeclarar);
                                        tipoIzq="int";
                                }else{
                                        tipoIzq=derecha;
                                }
                        }else //no existe variable
                        {
                                tipoIzq=derecha;

                        }
                }

                generarToken.insertar("Asignacion","=");
      E();
              tipoIzq=""; contExp=0;
      break;
    case POST_DECREMENTO:
	parser += "26 ";
      jj_consume_token(POST_DECREMENTO);
                esDecremento=true;
                String derecha= TablaDeSimbolos.buscarIDTsl(der);
                if(derecha==null){
                        derecha= TablaDeSimbolos.buscarIDTsg(der);
                        if(derecha==null){
                                tipoDec="int";
                                FormatoTS sinDeclarar = new FormatoTS("var",der,"int",0,null);
                                TablaDeSimbolos.insertarTsgVar(sinDeclarar);
                        }        
                        else
                                tipoDec=derecha;
                }else{

                        tipoDec=derecha;
                }
                generarToken.insertar("PostDecremento",token.image);
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void X() throws ParseException {
    if (jj_2_1(2)) {
		parser += "27 ";
      E();
    } else {
		parser += "28 ";
      ;
    }
  }

  static final public void H() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT:
	parser += "29 ";
      jj_consume_token(INT);
                //########### FUNCIONES ###############
                tipoParams.add(token.image);
                //########### VARIABLES ###############
                tipoVariable=token.image;
                tipoIzq=token.image;
      break;
    case CHARS:
	parser += "30 ";
      jj_consume_token(CHARS);
                //########### FUNCIONES ###############
                tipoParams.add(token.image);
                //########### VARIABLES ###############
                tipoVariable=token.image;
                tipoIzq=token.image;
      break;
    case BOOL:
	parser += "31 ";
      jj_consume_token(BOOL);
                //########### FUNCIONES ###############
                tipoParams.add(token.image);
                //########### VARIABLES ###############
                tipoVariable=token.image;
                tipoIzq=token.image;
      break;
    default:
      jj_la1[9] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void W() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASIG:
	parser += "32 ";
      jj_consume_token(ASIG);
                generarToken.insertar("Asignacion","=");
      E();

      break;
    default:
	parser += "33 ";
      jj_la1[10] = jj_gen;
      ;
    }
  }

  static final public void E() throws ParseException {
	  parser += "34 ";
    T();
    Ep();
                esMayor=false; esSuma=false; esAnd=false;
  }

  static final public void Ep() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AND:
	parser += "35 ";
      jj_consume_token(AND);
                esAnd=true;
                generarToken.insertar("And",token.image);
      T();
      Ep();
      break;
    default:
	parser += "36 ";
      jj_la1[11] = jj_gen;
      ;
    }
  }

  static final public void T() throws ParseException {
	  parser += "37 ";
    U();
    Tp();
  }

  static final public void Tp() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MAYOR:
	parser += "38 ";
      jj_consume_token(MAYOR);
                esMayor=true;
                generarToken.insertar("MayorQue",">");
      U();
      Tp();
      break;
    default:
	parser += "39 ";
      jj_la1[12] = jj_gen;
      ;
    }
  }

  static final public void U() throws ParseException {
	  parser += "40 ";
    V();
    Up();
  }

  static final public void Up() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SUMA:
	parser += "41 ";
      jj_consume_token(SUMA);
                esSuma=true;
                generarToken.insertar("Suma",token.image);
      V();
      Up();
      break;
    default:
	parser += "42 ";
      jj_la1[13] = jj_gen;
      ;
    }
  }

  static final public void V() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PAREN_A:
	parser += "43 ";
      jj_consume_token(PAREN_A);
                  generarToken.insertar("ParentesisAbierto","(");
      E();
      jj_consume_token(PAREN_C);
                                                                               generarToken.insertar("ParentesisCerrado",")");
      break;
    case DECIMAL:
	parser += "44 ";
      jj_consume_token(DECIMAL);
                // if(esLocal==false){
                        if(esMayor==false)
                                primerMayor="int";

                        if(esSuma==false)
                                primerSuma="int";

                        if(esAnd==false)
                                primerAnd="int";

                        if (esLlamada==false)
                        {
                                if(tipoIzq.equals("int")==false && tipoIzq!="" && esRetorno==false){
                                        System.out.println("Error sem\u00c3\u00a1ntico: tipo izqE("+tipoIzq+") no coincide tipo der (int) --> "+token.image+" en la l\u00c3\u00adnea "+token.beginLine);
                                }

                                if(tipoRetorno.equals("int")==false && esRetorno==true){
                                        System.out.println("Error sem\u00c3\u00a1ntico: el valor de retorno no es correcto --> "+tipoRetorno+" != int: "+token.image+" en la l\u00c3\u00adnea "+token.beginLine);
                                        esRetorno=false;
                                }
                                if(esMayor==true){
                                        if(primerMayor.equals("int")==false){
                                                System.out.println("Error semantico: la comprobacion de mayor que no es correcta Linea: "+token.beginLine);
                                        }
                                 esMayor=false;
                                }
                                if(esSuma==true){
                                        if(primerSuma!="int"){
                                                System.out.println("Error semantico: la comprobacion de suma no es correcta Linea: "+token.beginLine);

                                        }
                                esSuma=false;

                                }
                                if(esAnd==true){
                                        System.out.println("Error semantico: la comprobacion de and no es correcta Linea: "+token.beginLine);
                                        esAnd=false;
                                }
                        }else
                        {
                                contExp++;

                                if(contExp==1)
                                        tipoArrayParam="int";

                                if(!tipoArrayParam.equals("int") && tipoArrayParam != "")
                                {
                                        System.out.println("Error Sem\u00c3\u00a1ntico: la expresi\u00c3\u00b3n no es de tipo (int) en la linea "+token.beginLine+" en la columna "+token.beginColumn);
                                        tipoArrayParam="null";
                                }
                        }
                // }
                //MIRAR PARA LOS PARAMETROS EN LAS LLAMADAS
                generarToken.insertar("Numero",token.image);
      break;
    case CADENA:
	parser += "45 ";
      jj_consume_token(CADENA);
                // if(esLocal==false){
                        if(esMayor==false)
                                primerMayor="chars";

                        if(esSuma==false)
                                primerSuma="chars";

                        if(esAnd==false)
                                primerAnd="chars";

                        if(esLlamada==false)
                        {
                                if(tipoIzq.equals("chars")==false && tipoIzq!="" && esRetorno==false){
                                        System.out.println("Error sem\u00c3\u00a1ntico: tipoX izq("+tipoIzq+") no coincide tipo der (chars) --> "+token.image+" en la l\u00c3\u00adnea "+token.beginLine);
                                }
                                if(tipoRetorno.equals("chars")==false && esRetorno==true){
                                        System.out.println("Error sem\u00c3\u00a1ntico: el valor de retorno no es correcto --> "+tipoRetorno+" != chars: "+token.image+" en la l\u00c3\u00adnea "+token.beginLine);
                                        esRetorno=false;
                                }
                                if(esMayor==true){
                                        System.out.println("Error semantico: la comprobacion de qmayor que no es correcta Linea: "+token.beginLine);
                                        esMayor=false;
                                }
                                if(esSuma==true){
                                        System.out.println("Error semantico: la comprobacion de qsuma no es correcta Linea: "+token.beginLine);
                                        esSuma=false;
                                }
                                if(esAnd==true){
                                        System.out.println("Error semantico: la comprobacion de and no es correcta Linea: "+token.beginLine);
                                        esAnd=false;
                                }
                        }else
                        {
                                contExp++;
                                if(contExp==1)
                                        tipoArrayParam="chars";
                                if(!tipoArrayParam.equals("chars") && tipoArrayParam!="")
                                {
                                        System.out.println("Error Sem\u00c3\u00a1ntico: la expresi\u00c3\u00b3n no es de tipo chars en la linea "+token.beginLine+" en la columna "+token.beginColumn);
                                        tipoArrayParam="null";
                                }
                        }
                // 
                generarToken.insertar("Cadena",token.image);
      break;
    case TRUE:
	parser += "46 ";
      jj_consume_token(TRUE);
                // if(esLocal==false){
                        if(esMayor==false)
                                primerMayor="bool";

                        if(esSuma==false)
                                primerSuma="bool";

                        if(esAnd==false)
                                primerAnd="bool";

                        if(esLlamada==false)
                        {
                                if(tipoIzq.equals("bool")==false && tipoIzq!="" && esRetorno==false){
                                        System.out.println("Error sem\u00c3\u00a1ntico: tipoY izq("+tipoIzq+") no coincide tipo der (bool) --> "+token.image+" en la l\u00c3\u00adnea "+token.beginLine);
                                }
                                if(tipoRetorno.equals("bool")==false && esRetorno==true){
                                        System.out.println("Error sem\u00c3\u00a1ntico: el valor de retorno no es correcto --> "+tipoRetorno+" != bool: "+token.image+" en la l\u00c3\u00adnea "+token.beginLine);
                                        esRetorno=false;
                                }
                                if(esMayor==true){
                                        System.out.println("Error semantico: la comprobacion de mayor que no es correcta Linea: "+token.beginLine);
                                        esMayor=false;
                                }
                                if(esSuma==true){
                                        System.out.println("Error semantico: la comprobacion de suma no es correcta Linea: "+token.beginLine);
                                        esSuma=false;
                                }
                                if(esAnd==true){
                                        if(primerAnd!="bool")
                                                System.out.println("Error semantico: la comprobacion de and no es correcta Linea: "+token.beginLine);
                                        esAnd=false;
                                }
                        }else
                        {
                                contExp++;

                                if(contExp==1)
                                        tipoArrayParam="bool";

                                if(!tipoArrayParam.equals("bool") && tipoArrayParam != "")
                                {
                                        System.out.println("Error Sem\u00c3\u00a1ntico: la expresi\u00c3\u00b3n no es de tipo bool en la linea "+token.beginLine+" en la columna "+token.beginColumn);
                                        tipoArrayParam="null";
                                }
                        }
                // }

      break;
    case FALSE:
	parser += "47 ";
      jj_consume_token(FALSE);
                // if(esLocal==false){
                        if(esMayor==false)
                                primerMayor="bool";

                        if(esSuma==false)
                                primerSuma="bool";

                        if(esAnd==false)
                                primerAnd="bool";

                        if(esLlamada==false)
                        {
                                if(tipoIzq.equals("bool")==false && tipoIzq!="" && esRetorno==false){
                                        System.out.println("Error sem\u00c3\u00a1ntico: tipo izqQ("+tipoIzq+") no coincide tipo der (bool) --> "+token.image+" en la l\u00c3\u00adnea "+token.beginLine);
                                }
                                if(tipoRetorno.equals("bool")==false && esRetorno==true){
                                        System.out.println("Error sem\u00c3\u00a1ntico: el valor de retorno no es correcto --> "+tipoRetorno+" != bool: "+token.image+" en la l\u00c3\u00adnea "+token.beginLine);
                                        esRetorno=false;
                                }
                                if(esMayor==true){
                                        System.out.println("Error semantico: la comprobacion de mayor que no es correcta Linea: "+token.beginLine);
                                        esMayor=false;
                                }
                                if(esSuma==true){
                                        System.out.println("Error semantico: la comprobacion de suma no es correcta Linea: "+token.beginLine);
                                        esSuma=false;
                                }
                                if(esAnd==true){
                                        if(primerAnd!="bool")
                                                System.out.println("Error semantico: la comprobacion de and no es correcta Linea: "+token.beginLine);
                                        esAnd=false;
                                }
                        }else
                        {
                                contExp++;

                                if(contExp==1)
                                        tipoArrayParam="bool";

                                if(!tipoArrayParam.equals("bool") && tipoArrayParam != "")
                                {
                                        System.out.println("Error Sem\u00c3\u00a1ntico: la expresi\u00c3\u00b3n no es de tipo bool en la linea "+token.beginLine+" en la columna "+token.beginColumn);
                                        tipoArrayParam="null";
                                }
                        }
                // }

      break;
    case ID:
	parser += "48 ";
      jj_consume_token(ID);
                derLlamada = token.image;
                der = token.image;

                if(esLocal==false)
                {	
                        // System.out.println("llamada es "+esLlamada);
                        if(esLlamada==true)
                        {
                                contExp++;

                                String lexemaTipo = TablaDeSimbolos.buscarIDTsg(der);

                                if(lexemaTipo!=null)
                                {
                                        if(contExp==1)
                                                tipoArrayParam=lexemaTipo;

                                        if(!tipoArrayParam.equals(lexemaTipo) && tipoArrayParam != "")
                                        {
                                                System.out.println("Error Sem\u00c3\u00a1ntico: la expresi\u00c3\u00b3n no es de tipo "+ lexemaTipo+ " en la linea "+token.beginLine+" en la columna "+token.beginColumn);
                                                tipoArrayParam="null";
                                        }
                                }
								else //no existe variable
                                {
                                        FormatoTS sinDeclarar = new FormatoTS("var",der,"int",0,null);
                                        TablaDeSimbolos.insertarTsgVar(sinDeclarar);

                                        tipoArrayParam="int";
                                }

                                // esLlamada=false;
                        }
                }else//LOCAL
				{

					 if(esLlamada==true)
                    {
						contExp++;

						String lexemaTipo = TablaDeSimbolos.buscarIDTsl(der);
						// System.out.println("PARAMETRO ES: "+der+" y lexemaTipo: "+lexemaTipo);
						if(lexemaTipo==null)
						{
							lexemaTipo = TablaDeSimbolos.buscarIDTsg(der);
								if(lexemaTipo==null){
									FormatoTS sinDeclarar = new FormatoTS("var",der,"int",0,null);
									TablaDeSimbolos.insertarTsgVar(sinDeclarar);
									// tipoArrayParam="int";
									lexemaTipo="int";
								}
								
						}
						if(contExp==1)
							tipoArrayParam=lexemaTipo;
						
						// System.out.println("PARAMETRO despues de coma ES: "+der+" y lexemaTipo: "+lexemaTipo);

						if(!tipoArrayParam.equals(lexemaTipo) && tipoArrayParam != "")
						{
								System.out.println("Error Sem\u00c3\u00a1ntico: la expresi\u00c3\u00b3n no es de tipo "+ lexemaTipo+ " en la linea "+token.beginLine+" en la columna "+token.beginColumn);
								tipoArrayParam="null";
						}
						
                    }
				}

                generarToken.insertar("Identificador",token.image);
      Vp();
                if(esLocal==false) //estoy en la tsg y es llamada
                {		
				// System.out.println("ES llamada en global: "+esLlamada);
                        if(esLlamada == false && esParantC==false )
                        {

                                String derecha = TablaDeSimbolos.buscarIDTsg(der); //devuelve int, chars, bool

                                if(derecha != null)
                                {

                                        if(!tipoIzq.equals(derecha) && tipoIzq != "" && esRetorno==false)
                                        {
                                                System.out.println("Error semantico: tipo izqR("+tipoIzq+") no coincide tipo der ("+derecha+") --> "+der+" en la l\u00c3\u00adnea "+token.beginLine);
                                        }
                                        if(tipoRetorno.equals(derecha)==false && esRetorno==true){
                                                System.out.println("Error sem\u00c3\u00a1ntico: el valor de retorno no es correcto --> "+tipoRetorno+" != "+derecha+": "+der+" en la l\u00c3\u00adnea "+token.beginLine);
                                                esRetorno=false;
                                        }
                                        if(esMayor==false)
                                                primerMayor=derecha;

                                        if(esSuma==false)
                                                primerSuma=derecha;

                                        if(esAnd==false)
                                                primerAnd=derecha;

                                        if(esMayor==true){
                                                if(primerMayor!="int" || derecha!="int"){
                                                        System.out.println("Error semantico: la comprobacion de mayor que no es correcta Linea: "+token.beginLine);
                                                }
                                         esMayor=false;
                                        }
                                        if(esSuma==true){
                                                if(derecha!="int")
                                                System.out.println("Error semantico: la comprobacion de suma no es correcta Linea: "+token.beginLine);
                                                esSuma=false;
                                        }
                                        if(esAnd==true){
                                                if(primerAnd!="bool" || derecha!="bool")
                                                        System.out.println("Error semantico: la comprobacion de and no es correcta Linea: "+token.beginLine);
                                                esAnd=false;
                                        }

                                }else //no existe variable
                                {
                                        FormatoTS sinDeclarar = new FormatoTS("var",der,"int",0,null);
                                        TablaDeSimbolos.insertarTsgVar(sinDeclarar);

                                        if(esMayor==false)
                                                primerMayor="int";

                                        if(esSuma==false)
                                                primerSuma="int";

                                        if(esAnd==false)
                                                primerAnd="int";

                                        if(esMayor==true){
                                                if(primerMayor.equals("int")==false){
                                                        System.out.println("Error semantico: la comprobacion de mayor que no es correcta Linea: "+token.beginLine);
                                                }
                                         esMayor=false;
                                        }

                                        esSuma=false;

                                        if(esAnd==true){

                                                System.out.println("Error semantico: la comprobacion de and no es correcta Linea: "+token.beginLine);
                                                esAnd=false;
                                        }

                                        if(!tipoIzq.equals("int") && tipoIzq!="" && esRetorno==false)
                                        {
                                                System.out.println("Error semantico: tipo izqA("+tipoIzq+") no coincide tipo der (int) --> "+der+" en la l\u00c3\u00adnea "+token.beginLine);
                                        }
                                        if(tipoRetorno.equals(derecha)==false && esRetorno==true){
                                                System.out.println("Error sem\u00c3\u00a1ntico: el valor de retorno no es correcto --> "+tipoRetorno+" != "+derecha+": "+der+" en la l\u00c3\u00adnea "+token.beginLine);
                                                esRetorno=false;
                                        }
                                }
                        }
                }else{//LOCAL
					// System.out.println("Es llamada en local: "+esLlamada);
                        if(esLlamada == false && esParantC==false)
                        {
                                
                                String derecha = TablaDeSimbolos.buscarIDTsl(der); //devuelve int, chars, bool
                                // System.out.println("DERECHA ES : "+derecha);
                                if(derecha != null)//si existe derecha
                                {

                                        if(!tipoIzq.equals(derecha) && tipoIzq != "" && esRetorno==false)
                                        {
                                                System.out.println("Error semantico: tipo izqD("+tipoIzq+") no coincide tipo der ("+derecha+") --> "+der+" en la l\u00c3\u00adnea "+token.beginLine);
                                        }
                                        if(tipoRetorno.equals(derecha)==false && esRetorno==true){
                                                System.out.println("Error sem\u00c3\u00a1ntico: el valor de retorno no es correcto --> "+tipoRetorno+" != "+derecha+": "+der+" en la l\u00c3\u00adnea "+token.beginLine);
                                                esRetorno=false;
                                        }
                                        if(esMayor==false)
                                                primerMayor=derecha;

                                        if(esSuma==false)
                                                primerSuma=derecha;

                                        if(esAnd==false)
                                                primerAnd=derecha;


                                        if(esMayor==true){
                                                if(primerMayor!="int" || derecha!="int"){
                                                        System.out.println("Error semantico: la comprobacion de mayor que no es correcta Linea: "+token.beginLine);
                                                }
                                         esMayor=false;
                                        }
                                        if(esSuma==true){
                                                if(derecha!="int")
                                                System.out.println("Error semantico: la comprobacion de suma no es correcta Linea: "+token.beginLine);
                                                esSuma=false;
                                        }
                                        if(esAnd==true){
                                                if(primerAnd!="bool" || derecha!="bool")
                                                        System.out.println("Error semantico: la comprobacion de and no es correcta Linea: "+token.beginLine);
                                                esAnd=false;
                                        }

                                }else //no existe variable entonces vamos a la global 
                                {
                                        // System.out.println("DER2 es: : "+der);

                                        derecha= TablaDeSimbolos.buscarIDTsg(der);
                                        // System.out.println("DERECHA2 es: : "+derecha);

                                        if(derecha==null){
                                                FormatoTS sinDeclarar = new FormatoTS("var",der,"int",0,null);
                                                TablaDeSimbolos.insertarTsgVar(sinDeclarar);
                                                derecha="int";
                                        }
                                        if(esMayor==false)
                                        primerMayor="int";

                                        if(esSuma==false)
                                                primerSuma="int";

                                        if(esAnd==false)
                                                primerAnd="int";

                                        if(esMayor==true){
                                                if(primerMayor.equals("int")==false){
                                                        System.out.println("Error semantico: la comprobacion de mayor que no es correcta Linea: "+token.beginLine);
                                                }
                                         esMayor=false;
                                        }

                                        esSuma=false;

                                        if(esAnd==true){

                                                System.out.println("Error semantico: la comprobacion de and no es correcta Linea: "+token.beginLine);
                                                esAnd=false;
                                        }
                                        // System.out.println("TipoIzq es: "+tipoIzq);
                                                // System.out.println("DerechaQ es: "+derecha);
                                        if(!tipoIzq.equals(derecha) && tipoIzq!="" && esRetorno==false)
                                        {
                                                System.out.println("Error semantico: tipo izqF("+tipoIzq+") no coincide tipo der (int) --> "+der+" en la l\u00c3\u00adnea "+token.beginLine);
                                        }
                                        if(tipoRetorno.equals(derecha)==false && esRetorno==true){
                                                System.out.println("Error sem\u00c3\u00a1ntico: el valor de retorno no es correcto --> "+tipoRetorno+" != "+derecha+": "+der+" en la l\u00c3\u00adnea "+token.beginLine);
                                                esRetorno=false;
                                        }
                                }
                                if(esDecremento==true){
                                        if(tipoDec!="int")
                                                System.out.println("Error semantico: la comprobacion de postDecremento no es correcta Linea: "+token.beginLine);

                                                esDecremento=false;
                                }
                        }
                }
                // esLlamada=false;
      break;
    default:
      jj_la1[14] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void Vp() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case POST_DECREMENTO:
    case ASIG:
    case PAREN_A:
	
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PAREN_A:
	  parser += "49 ";
        jj_consume_token(PAREN_A);
                esLlamada = true;
                copiaLLamada = derLlamada;
                generarToken.insertar("ParentesisAbierto","(");
        L();
        jj_consume_token(PAREN_C);
                // TablaDeSimbolos.
				// System.out.println("Copia es: "+copiaLLamada);
                String derLlamada2 = TablaDeSimbolos.buscarLlamadaTsg(copiaLLamada,contParamLlamada, tipoParamsLlamada);
				// System.out.println("DerLlamada es: "+derLlamada2);
                // if(esLocal==false)
                // {
                        if(derLlamada2 != null)
                        {
                                if(!tipoIzq.equals(derLlamada2) && tipoIzq != "" && esRetorno==false)
                                {
                                        System.out.println("Error semantico: tipo izqT("+tipoIzq+") no coincide tipo der ("+derLlamada2+") --> "+copiaLLamada+" en la l\u00c3\u00adnea "+token.beginLine);
                                }
                        }else
                        {
                                System.out.println("Error Sem\u00c3\u00a1tico: la funci\u00c3\u00b3n "+copiaLLamada+" no est\u00c3\u00a1 declarada con n\u00c2\u00ba de parametros: "+contParamLlamada+" o con tipo de parametros distintos en la l\u00c3\u00adnea "+token.beginLine);

                        }

                // }

                generarToken.insertar("ParentesisCerrado",")");
				esLlamada=false;
				esParantC=true;
                contParamLlamada=0;
                contExp=0;
                tipoParamsLlamada = new ArrayList<String>();
        break;
      case POST_DECREMENTO:
	  parser += "50 ";
        jj_consume_token(POST_DECREMENTO);
                esDecremento=true;
                String derecha= TablaDeSimbolos.buscarIDTsl(der);
                if(derecha==null){
                        derecha= TablaDeSimbolos.buscarIDTsg(der);
                        if(derecha==null)
                                tipoDec="int";
                        else
                                tipoDec=derecha;
                }else{

                        tipoDec=derecha;
                }


                generarToken.insertar("PostDecremento",token.image);
        break;
      case ASIG:
	  parser += "51 ";
        jj_consume_token(ASIG);
                generarToken.insertar("Asignacion","=");
        V();
        break;
      default:
        jj_la1[15] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
	parser += "52 ";
      jj_la1[16] = jj_gen;
      ;
    }
  }

  static final public void L() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TRUE:
    case FALSE:
    case PAREN_A:
    case ID:
    case CADENA:
    case DECIMAL:
	parser += "53 ";
      E();
                contParamLlamada=1;
                tipoParamsLlamada.add(tipoArrayParam);
                contExp=0;
                // tipoArrayParam="";//PARECE QUE SOBRA PORQUE SE PISA

      Q();
      break;
    default:
	parser += "54 ";
      jj_la1[17] = jj_gen;
      ;
    }
  }

  static final public void Q() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMA:
	parser += "55 ";
      jj_consume_token(COMA);
                contParamLlamada++;
      E();
                tipoParamsLlamada.add(tipoArrayParam);
                // tipoArrayParam="";//PARECE QUE SOBRA PORQUE SE PISA
                contExp=0;
      Q();
      break;
    default:
	parser += "56 ";
      jj_la1[18] = jj_gen;
      ;
    }
  }

  static private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  static private boolean jj_3R_16() {
    if (jj_scan_token(SUMA)) return true;
    return false;
  }

  static private boolean jj_3R_8() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_16()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_4() {
    if (jj_3R_7()) return true;
    if (jj_3R_8()) return true;
    return false;
  }

  static private boolean jj_3R_9() {
    if (jj_scan_token(MAYOR)) return true;
    return false;
  }

  static private boolean jj_3R_5() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_9()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_2() {
    if (jj_3R_4()) return true;
    if (jj_3R_5()) return true;
    return false;
  }

  static private boolean jj_3R_15() {
    if (jj_scan_token(ID)) return true;
    if (jj_3R_17()) return true;
    return false;
  }

  static private boolean jj_3R_14() {
    if (jj_scan_token(FALSE)) return true;
    return false;
  }

  static private boolean jj_3R_12() {
    if (jj_scan_token(CADENA)) return true;
    return false;
  }

  static private boolean jj_3R_13() {
    if (jj_scan_token(TRUE)) return true;
    return false;
  }

  static private boolean jj_3R_21() {
    if (jj_scan_token(ASIG)) return true;
    return false;
  }

  static private boolean jj_3_1() {
    if (jj_3R_1()) return true;
    return false;
  }

  static private boolean jj_3R_6() {
    if (jj_scan_token(AND)) return true;
    return false;
  }

  static private boolean jj_3R_3() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_6()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_19() {
    if (jj_scan_token(PAREN_A)) return true;
    return false;
  }

  static private boolean jj_3R_18() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_19()) {
    jj_scanpos = xsp;
    if (jj_3R_20()) {
    jj_scanpos = xsp;
    if (jj_3R_21()) return true;
    }
    }
    return false;
  }

  static private boolean jj_3R_17() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_18()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_11() {
    if (jj_scan_token(DECIMAL)) return true;
    return false;
  }

  static private boolean jj_3R_1() {
    if (jj_3R_2()) return true;
    if (jj_3R_3()) return true;
    return false;
  }

  static private boolean jj_3R_7() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_10()) {
    jj_scanpos = xsp;
    if (jj_3R_11()) {
    jj_scanpos = xsp;
    if (jj_3R_12()) {
    jj_scanpos = xsp;
    if (jj_3R_13()) {
    jj_scanpos = xsp;
    if (jj_3R_14()) {
    jj_scanpos = xsp;
    if (jj_3R_15()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_10() {
    if (jj_scan_token(PAREN_A)) return true;
    if (jj_3R_1()) return true;
    return false;
  }

  static private boolean jj_3R_20() {
    if (jj_scan_token(POST_DECREMENTO)) return true;
    return false;
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public LexicoSintacticoTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private Token jj_scanpos, jj_lastpos;
  static private int jj_la;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[19];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x8000ff,0x700,0x700,0x700,0x40000,0x8000fa,0x8000fa,0x800098,0x224000,0x700,0x20000,0x10000,0x8000,0x2000,0x3a01800,0x224000,0x224000,0x3a01800,0x40000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
  static final private JJCalls[] jj_2_rtns = new JJCalls[1];
  static private boolean jj_rescan = false;
  static private int jj_gc = 0;

  /** Constructor with InputStream. */
  public LexicoSintactico(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public LexicoSintactico(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new LexicoSintacticoTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 19; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 19; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public LexicoSintactico(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new LexicoSintacticoTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 19; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 19; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public LexicoSintactico(LexicoSintacticoTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 19; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(LexicoSintacticoTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 19; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  static final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  static private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;
  static private int[] jj_lasttokens = new int[100];
  static private int jj_endpos;

  static private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[33];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 19; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 33; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

  static private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 1; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  static private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
